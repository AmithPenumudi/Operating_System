<!DOCTYPE html>
<html>
    <head>
        <title>Page replacement</title>



        <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" />
        <script type="text/javascript" src="lru.js"></script>

    </head>
    <body>

        <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
          <a class="navbar-brand" href="../Index/index.html#pagerepl">Home</a>
          <a class="navbar-brand " href="lruindex.html">Simulate</a>

              <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation" style="">
                <span class="navbar-toggler-icon"></span>
              </button>


        </nav>
        <br>
        <div class="container">

                    <h1 class="display-3">Page replacement Algorithm</h1>
                         <hr class="my-4">
                    <p>The page replacement algorithm decides which memory page is to be replaced. The process of replacement is sometimes called swap out or write to disk. Page replacement is done when the requested page is not found in the main memory (page fault).</p>

                    <p>A page replacement algorithm is evaluated by running the particular algorithm on a string of
                             memory references and compute the page faults.Referenced string is a sequence of pages being referenced.
                              Page fault is not an error. Contrary to what their name might suggest, page faults are not errors and
                              are common and necessary to increase the amount of memory available to programs in any operating
                              system that utilizes virtual memory, including Microsoft Windows, Mac OS X, Linux and Unix.</p>

                              <p>Each operating system uses different page replacement algorithms. To select the particular algorithm,
                                    the algorithm with lowest page fault rate is considered. <br><br>
                                    1.  FIFO (First In, First-Out) <br>
                                    2.  LRU (Least recently used)  <br>
                                    3.  MRU (Most recently used) <br>
                                    4.  Optimal page replacement algorithm   <br>
                                    5.  MFU (Most frequently used)  <br>
                                    6.  Second chance <br>
                                    7.  Enhanced second chance <br>
                                 </p>

          <hr class="my-4">


                       <hr class="my-4">



                        <h2 class="dispThelay-3">FIFO (First In, First-Out)</h2>
                             <hr class="my-4">
                       <p>With the FIFO algorithm, the OS maintains a queue to keep track of all the pages in memory, with the most recent
                            arrival at the back (tail of the queue), and the oldest arrival in front (head of the queue). When the system
                            needs space, a page will be replaced. With FIFO, the page at the front of the queue (the oldest page) is selected
                             for replacement. However, FIFO is know to suffer from a problem known as Belady's anomaly which occurs when
                             increasing the number of page frames results in an increase in the number of page faults for a given memory
                             access pattern. <br>
                             <p>Belady's anomaly - Belady's anomaly proves that it is possible to have more page faults when increasing
                                  the number of page frames while using the First in First Out (FIFO) page replacement algorithm. <br>
                                   For example, if we consider reference string 3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4 and 3 slots,
                                    we get 9 total page faults, but if we increase slots to 4, we get 10 page faults.</p> <br>
                              For example,</p>
                              <img src="fifoimage.png" alt="Italian Trulli">
              <hr class="my-4">



                <h2 class="dispThelay-3">LRU (Least recently used)</h2>
                     <hr class="my-4">
              <p>In the Least Recently Used (LRU) page replacement policy, the page that is used least recently will be replaced. </p>
                 <p> For Example,</p>
              <img src="lruimage.png" alt="Italian Trulli">
      <hr class="my-4">

      <hr class="my-4">


      <h2 class="dispThelay-3">MRU (Most recently used) </h2>
      <hr class="my-4">
      <p>In the most Recently Used (LRU) page replacement policy, the page that is used most recently will be replaced. </p>

      <p> For example, let  reference string be 7, 0, 1, 2, 0, 3, 0, 4, 2, 3 </p>
 <img src="mru_image.png" alt="Italian Trulli">


 <hr class="my-4">
      <h2 class="dispThelay-3">Optimal page replacement</h2>
         <br>
      <p> The algorithm has the lowest page fault rate compared to all other algorithms.  <br>
        Often called Balady's Min Basic idea, idea is to replace the page that will not be referenced for the longest time.  <br> <br>

           This algorithm replaces the page that will not be referred by the CPU in future for the longest time.  <br><br>
           It is practically impossible to implement this algorithm.
           This is because the pages that will not be used in future for the longest time can not be predicted. <br><br>
           However, it is the best known algorithm and gives the least number of page faults.
           Hence, it is used as a performance measure criterion for other algorithms.  <br>


</p>

              <p>        For Example,</p>
          <img src="opr_image.png" alt="Italian Trulli">
      <hr class="my-4">

      <hr class="my-4">



      <h2 class="dispThelay-3">MFU (Most frequently used) </h2>
           <hr class="my-4">

     <p> The MFU algorithm replaces the page which was used most frequently. </p>
          <br><br>
          <p> For example, let reference string be 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p>
          <img src="mfuimage.jpg" alt="Italian Trulli">

</p>

      <h2 class="ddispThelay-3">Second chance algorithm</h2>
           <hr class="my-4">
      <p>The second chance algorithm is an approximation of LRU based on using one use bit for each page. When a page is used
        its reference bit is set to 1. We also use a pointer to the next victim which is initialized to the first page/frame. When a page is loaded,
         it is set to point to the next frame. The list of pages is considered as a circular queue. When a page is considered for replacement,
          the reference bit for the next victim page is examined. If it is zero that page is replaced otherwise the reference bit is set to zero,
           the next victim pointer is advanced, and the process is repeated until a page is found with a zero reference bit.
          <br> <br> 
             <br><p> For Example,</p>
             <img src="secondchance_image.png" alt="Italian Trulli">
             <hr class="my-4">



             <h2 class="dispThelay-3">Enhanced Second-Chance Algorithm</h2>
                  <hr class="my-4">
            <p>
           Enhanced Second-Chance Algorithm. The enhanced second chance algorithm uses a reference bit and a modify bit for each page. When a page is used its reference bit is set to 1. We also use a pointer to the next victim
           which is initialized to the first page/frame. When a page is loaded, the next victim pointer will be set to the next
           frame after the one just loaded. The list of pages is considered as a circular queue. When a page is considered for replacement,
            the bit pairs for each page are considered
            (ref,mod):    <br> <br>

         1.  (0,0) neither recently used nor modified, best!  <br>
         2.  (0,1 ) modified but not recently used, will need to be written.  <br>
         3.  (1,0 ) recently used but clean—likely to be used again.  <br>
         4.  (1,1 ) both—likely to be used again and will need to be written.    <br>  <br>
        There are three loops through the circular buffer containing these bits that may be used. They are:   <br>
        (a) Cycle through the buffer looking for (0,0). If one is found, use that page. <br>
        (b) Cycle through the buffer looking for (0,1). Set the use bit to zero for all frames bypassed. <br>
        (c) If step 2 failed, all use bits will now be zero and repetition of steps 1 and 2 are guaranteed to find a frame for replacement.
            </p>
            <br><p> For example, consider reference string -> 0, 1, 3, 6, 2, 4, 5, 2, 5, 0, 3, 1, 2, 5, 4, 1, 0</p>
            <img src="second2_image.png" alt="Italian Trulli">
   <hr class="my-4">





	</body>
</html>
